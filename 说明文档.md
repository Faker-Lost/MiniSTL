# 简易STL——MiniSTL

根据数据结构、STL源码剖析，手写简易版STL。

## 1.Vector 容器 2024.5.27

**1 vector的扩容过程**

1.分配一个更大的内存块，通常时当前大小的两倍；

2.将当前的所有元素移到新的内存中；

3.销毁旧元素，并释放旧内存块；

4.插入新元素

**2 vector中push_back和emplace的区别：**

`std::vector::push_back` 和 `std::vector::emplace_back` 都是在 `std::vector` 的末尾添加一个新元素，但它们添加元素的方式不同。

- `push_back` 会对给定的对象进行拷贝或移动构造，以将元素添加到 `vector` 的末尾。
- `emplace_back` 则使用给定的参数直接在 `vector` 的末尾构造一个元素，无需拷贝或移动操作，这通常更高效。

**3 reserve()的使用：**

`std::vector::reserve()` 用于预分配内存，以避免在添加新元素时重新分配内存。当知道将要存储大量元素，但又不想在每次插入时都可能发生内存重新分配时，使用 `reserve()` 可以提高性能。这样可以减少因扩容导致的不必要的内存分配和元素拷贝。

**4 如何减少vector的占用空间：**

可以使用 `std::vector::shrink_to_fit` 方法来请求移除未使用的容量，减少 `vector` 的内存使用。这个函数是 C++11 引入的，它会尝试压缩 `std::vector` 的容量，使其等于其大小。但是，这只是一个请求，并不保证容量会减少，因为这依赖于实现。

**5 如何检查vector为空：**

使用 `std::vector::empty()` 方法可以检查 `vector` 是否没有元素。这比使用 `size()` 方法（比较 `size() == 0`）更首选，因为 `empty()` 通常可以保证是常数时间复杂度的操作。

**6 迭代器失效，如何避免:**

当 `vector` 进行操作，如增加或删除元素，尤其是在中间插入或删除元素时，迭代器可能会失效。例如：

- 如果 `vector` 进行了重新分配，所有指向元素的迭代器都会失效。
- 如果在 `vector` 中间插入或删除元素，从该点到末尾的所有迭代器都会失效。

解决方案是最好使用标准库提供的算法，如 `std::remove` 和 `std::remove_if` 结合 `vector::erase` 方法来删除元素。这些算法在设计时已经考虑了迭代器失效的问题。

## 2.List容器 2024.5.30

**1.删除list中的特定元素：**

```c++
template <typename T>
void removeAllInstances(std::list<T>& lst, const T& value) {
    for (auto it = lst.begin(); it != lst.end(); /* no increment here */) {
        if (*it == value) {
            it = lst.erase(it);  // erase() returns iterator to the next element
        } else {
            ++it;  // Only increment if not erased
        }
    }
}
```

**2. STL中list特性：**

list是一个序列容器，允许非联系内存分配

list有以下重要特性：

- 双向链表：允许两个方向遍历。
- 非连续内存：由于它是链表，元素不存储在连续的内存位置。这意味着除了通过迭代器外，无法通过常规索引来访问元素。
- 动态大小：与数组不同，list可以根据需要动态增长或缩减
- 插入和删除：时间复杂度O(1)。
- 不支持随机访问：不支持快速随机访问，时间复杂度为O(n)。
- 额外内存开销：每个元素都需要额外的内存来存储前后元素的指针。

**3.list的迭代器失效情况：**

- **插入操作**：在 `list` 中插入操作不会导致任何现有迭代器失效，包括指向插入位置的迭代器。插入操作后，原来的迭代器仍然指向它们原来指向的元素。
- **删除操作**：删除操作会导致指向被删除元素的迭代器失效。然而，其他迭代器，包括指向前一个和后一个元素的迭代器，仍然有效。

**4. list和vector的区别：**

- **内部实现**：
  - `list` 是一个双向链表，不支持随机访问。
  - `vector` 是一个动态数组，支持快速随机访问。
- **性能特点**：
  - list：
    - 插入和删除操作快（O(1)），不论在容器中的哪个位置。
    - 遍历操作慢（O(n)），因为它不支持随机访问。
  - vector：
    - 插入和删除操作在尾部快（O(1)），但在中间或开头慢（O(n)），因为可能需要移动元素。
    - 遍历- **内部实现**：
  - `vector` 是基于连续内存空间的动态数组实现，这意味着它的元素存储在一个连续的内存块中。
  - `list` 是基于双向链表实现的，它的每个元素都是单独的内存块，通过指针连接。

## 3. Deque的实现 2024.06.03

deque双端队列，支持两端添加和删除元素

**特性：**

- 支持前端和后端快速插入和删除
- 随机访问：deque[2];
- 动态扩展
- 迭代有效性
- 内存局限性

**STL基本用法：**

包含头文件：

`#include<deque>`

声明deque对象：

`deque<int< myDeque;`

插入元素：

`myDeque.push_front(1);`

`myDeque.push_back(2);`

删除元素：

```c++
myDeque.pop_front(1);
myDeque.pop_back(2)
```

**工作原理：**

`C++ STL中`的 `deque`（双端队列）确实规定了接口和时间复杂度，但没有规定特定的实现细节。`C++` 标准描述了每个容器的行为和性能要求，具体实现留给了实现者。这里介绍循环数组的方式来实现双端队列：

**总体思路：**

- elements：动态数组存储队列元素;
- capacity:容量；
- size：数组长度；
- frontIndex、backIndex:前端和后端元素
- 循环数组：通过模运算来实现数组的循环效果，使得队列可以在数组的任意一端进行插入和删除操作, 因为索引越界后直接取模从另一端开始就可以了。
- 动态调整大小：当数组达到容量限制时，自动拓展，并实现现有元素复制到新的更大的数组中；
- 索引计算：利用模运算计算新的forntIndex和backIndex

**deque和vector的区别：**

1. 内存分配：vector使用单一连续的内存空间来存储元素，deque使用分散的内存块
2. 插入效率：deque前端和后端插入和删除操作效率高，vector在尾部插入和删除效率高，前端效率低；
3. 随机访问：vector提供更快的随机访问，deque随机访问性低
4. 内存消耗：vector扩展时可能会有较大的内存分配成本，deque不需要大量的内存分配成本

## 4.Stack 2024.06.07

**特性**：

Stack是一个容器适配器，不是一个独立的数据结构，而是构建在其他容器之上的；默认轻快下，stack使用deque作为底层容器，但也可以选择使用vector、list等其他容器来作为底层支持

**基本操作：**

```c++
#include<stack>
stack<int> st;
st.push(1);
st.push(2);
int element = st.top();
st.pop();
boo isEmpty = stack.empty();
szie_t stackSize = st.size();
```

**与标准库的区别：**

- 允许实例化中选择不同的底层容器
- 错误处理：添加了异常处理栈为空的情况

**栈特点：**

- 先进后出

**栈溢出：**

- 发生在栈已满的执行push操作
- 栈为空执行pop操作

**如何用栈判断字符串中的括号是否匹配：**

- 遍历整个字符串
- 遇到左括号，将其压入栈
- 如果遇到闭括号，检查栈顶元素是否为对应的开括号
  - 是 栈中弹出栈顶元素
  - 不是 栈为空 字符串括号不平衡
- 遍历结束，若栈为空，则平衡，否则不平衡

## 5 HashTable

HashTable是底层数据结构，无序关联容器包括unordered_set unordered_map 基于哈希表实现。

**什么是哈希表？它是如何工作的？**

- 答案：哈希表是一种使用哈希函数组织数据，以便快速插入和搜索的数据结构。它通过将键映射到表中的位置来存储键值对。哈希函数将每个键转换为哈希表中的索引，该索引决定了键值对在表中的存储位置。如果两个键映射到同一个索引，就会产生冲突，这通常通过链表或开放寻址法来解决。

**哈希冲突是什么？如何处理哈希冲突？**

答案：哈希冲突发生在不同的键通过哈希函数映射到哈希表的同一位置时。处理哈希冲突的方法有：

- **链表法（分离链接法）**：在每个哈希表索引上维护一个链表，所有映射到该索引的元素都会被存储在链表中。
- **开放寻址法**：如果发生冲突，

## 6. RB-Tree 2024.6.4

**结构体：**

```c++
struct Node {
Key key;
Value val;
Color color;
Node *left;
Node *right;
Node *parent;

// 构造函数
Node(const Key &k, Color c, Node *p = nullptr)
    : key(k), color(c), left(nullptr), right(nullptr), parent(p) {}
};
```

每个结构体需要记录自身颜色、键值、左孩子、右孩子和父节点的指针， 该结构体的构造函数会分配父节点指针， 其余指针为空指针;

**insertFixup函数:**

用于插入新节点后修复可能违反红黑树性质的情况。根据红黑树性质进行

1. 颜色调整
2. 旋转

逻辑思路：

1. 父节点是爷爷节点的左孩子
   1. 叔叔节点为红色
      1. 更改叔叔节点和父节点为黑色
      2. 将爷爷节点改为红色
      3. 以爷爷节点为目标继续判断
   2. 叔叔节点为黑色或不存在
      1. 如果新节点是父节点的右孩子，将操作的目标节点变为其父节点，左旋
      2. 操作节点为黑色，爷爷节点红色，
      3. 右旋爷爷节点
2. 父节点是爷爷节点的右孩子
   1. 叔叔红色
      1. 更改叔叔和父节点为黑色
      2. 爷爷设为红色
      3. 以爷爷节点为目标继续调整
   2. 叔叔节点为黑色或不存在
      1. 新节点是父节点的左孩子，将操作的目标节点为其父节点，右旋
      2. 将操作节点设为黑色，爷爷节点为红色
      3. 左旋爷爷节点



**红黑树的特性：**

- 每个节点要么是红色，要么是黑色
- 根节点是黑色
- 叶子节点是黑色
- 如果一个节点是红色，则它的两个子节点都是黑色
- 从任一节点到其每个叶子的所有简单路径都包含相同的黑色节点

**红黑树的时间复杂度是O(logn),其近似平衡的二叉搜索树**

**如何验证一个二叉树是不是红黑树？**

判断是否满足红黑树的五个特性。遍历数的各个节点来检查颜色以及路径上的褐色节点数目是否一致

## 7. Set 2024 06. 08

Set基于红黑树实现，用于存储一组唯一的元素，并按照元素的值进行排序；

Set是有序的关联容器，使用红黑树实现。

特性：

- 唯一性
- 有序性
- 插入元素

使用方法：

`````
#include<set>

std::set<int> myset;

myset.insert(2);

myset.erase(2);

auto it = myset.find(2);
if(it!=myset.end())
{

}
`````

## 8. unordered_set





## 9. multiset

基于红黑树实现，允许存储多个相同元素，并按照元素的值进行排序；

**特性：**

1. 有序性：
2. 允许重复
3. 基于红黑树实现

