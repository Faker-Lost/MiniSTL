# 简易STL——MiniSTL

根据数据结构、STL源码剖析，手写简易版STL。

## 1.Vector的实现 2024.5.27

**1 vector的扩容过程**

1.分配一个更大的内存块，通常时当前大小的两倍；

2.将当前的所有元素移到新的内存中；

3.销毁旧元素，并释放旧内存块；

4.插入新元素

**2 vector中push_back和emplace的区别：**

`std::vector::push_back` 和 `std::vector::emplace_back` 都是在 `std::vector` 的末尾添加一个新元素，但它们添加元素的方式不同。

- `push_back` 会对给定的对象进行拷贝或移动构造，以将元素添加到 `vector` 的末尾。
- `emplace_back` 则使用给定的参数直接在 `vector` 的末尾构造一个元素，无需拷贝或移动操作，这通常更高效。

**3 reserve()的使用：**

`std::vector::reserve()` 用于预分配内存，以避免在添加新元素时重新分配内存。当知道将要存储大量元素，但又不想在每次插入时都可能发生内存重新分配时，使用 `reserve()` 可以提高性能。这样可以减少因扩容导致的不必要的内存分配和元素拷贝。

**4 如何减少vector的占用空间：**

可以使用 `std::vector::shrink_to_fit` 方法来请求移除未使用的容量，减少 `vector` 的内存使用。这个函数是 C++11 引入的，它会尝试压缩 `std::vector` 的容量，使其等于其大小。但是，这只是一个请求，并不保证容量会减少，因为这依赖于实现。

**5 如何检查vector为空：**

使用 `std::vector::empty()` 方法可以检查 `vector` 是否没有元素。这比使用 `size()` 方法（比较 `size() == 0`）更首选，因为 `empty()` 通常可以保证是常数时间复杂度的操作。

**6 迭代器失效，如何避免:**

当 `vector` 进行操作，如增加或删除元素，尤其是在中间插入或删除元素时，迭代器可能会失效。例如：

- 如果 `vector` 进行了重新分配，所有指向元素的迭代器都会失效。
- 如果在 `vector` 中间插入或删除元素，从该点到末尾的所有迭代器都会失效。

解决方案是最好使用标准库提供的算法，如 `std::remove` 和 `std::remove_if` 结合 `vector::erase` 方法来删除元素。这些算法在设计时已经考虑了迭代器失效的问题。

## 2.List的实现 2024.5.30

**1.删除list中的特定元素：**

```c++
template <typename T>
void removeAllInstances(std::list<T>& lst, const T& value) {
    for (auto it = lst.begin(); it != lst.end(); /* no increment here */) {
        if (*it == value) {
            it = lst.erase(it);  // erase() returns iterator to the next element
        } else {
            ++it;  // Only increment if not erased
        }
    }
}
```

**2. STL中list特性：**

list是一个序列容器，允许非联系内存分配

list有以下重要特性：

- 双向链表：允许两个方向遍历。
- 非连续内存：由于它是链表，元素不存储在连续的内存位置。这意味着除了通过迭代器外，无法通过常规索引来访问元素。
- 动态大小：与数组不同，list可以根据需要动态增长或缩减
- 插入和删除：时间复杂度O(1)。
- 不支持随机访问：不支持快速随机访问，时间复杂度为O(n)。
- 额外内存开销：每个元素都需要额外的内存来存储前后元素的指针。

**3.list的迭代器失效情况：**

- **插入操作**：在 `list` 中插入操作不会导致任何现有迭代器失效，包括指向插入位置的迭代器。插入操作后，原来的迭代器仍然指向它们原来指向的元素。
- **删除操作**：删除操作会导致指向被删除元素的迭代器失效。然而，其他迭代器，包括指向前一个和后一个元素的迭代器，仍然有效。

**4. list和vector的区别：**

- **内部实现**：
  - `list` 是一个双向链表，不支持随机访问。
  - `vector` 是一个动态数组，支持快速随机访问。
- **性能特点**：
  - list：
    - 插入和删除操作快（O(1)），不论在容器中的哪个位置。
    - 遍历操作慢（O(n)），因为它不支持随机访问。
  - vector：
    - 插入和删除操作在尾部快（O(1)），但在中间或开头慢（O(n)），因为可能需要移动元素。
    - 遍历- **内部实现**：
  - `vector` 是基于连续内存空间的动态数组实现，这意味着它的元素存储在一个连续的内存块中。
  - `list` 是基于双向链表实现的，它的每个元素都是单独的内存块，通过指针连接。

## 3. Deque的实现 2024.06.03

deque双端队列，支持两端添加和删除元素

**特性：**

- 支持前端和后端快速插入和删除
- 随机访问：deque[2];
- 动态扩展
- 迭代有效性
- 内存局限性

**STL基本用法：**

包含头文件：

`#include<deque>`

声明deque对象：

`deque<int< myDeque;`

插入元素：

`myDeque.push_front(1);`

`myDeque.push_back(2);`

删除元素：

```c++
myDeque.pop_front(1);
myDeque.pop_back(2)
```

**工作原理：**

`C++ STL中`的 `deque`（双端队列）确实规定了接口和时间复杂度，但没有规定特定的实现细节。`C++` 标准描述了每个容器的行为和性能要求，具体实现留给了实现者。这里介绍循环数组的方式来实现双端队列：

**总体思路：**

- elements：动态数组存储队列元素;
- capacity:容量；
- size：数组长度；
- frontIndex、backIndex:前端和后端元素
- 循环数组：通过模运算来实现数组的循环效果，使得队列可以在数组的任意一端进行插入和删除操作, 因为索引越界后直接取模从另一端开始就可以了。
- 动态调整大小：当数组达到容量限制时，自动拓展，并实现现有元素复制到新的更大的数组中；
- 索引计算：利用模运算计算新的forntIndex和backIndex

**deque和vector的区别：**

1. 内存分配：vector使用单一连续的内存空间来存储元素，deque使用分散的内存块
2. 插入效率：deque前端和后端插入和删除操作效率高，vector在尾部插入和删除效率高，前端效率低；
3. 随机访问：vector提供更快的随机访问，deque随机访问性低
4. 内存消耗：vector扩展时可能会有较大的内存分配成本，deque不需要大量的内存分配成本

## 4.Stack的实现 2024.06.07

**特性**：

Stack是一个容器适配器，不是一个独立的数据结构，而是构建在其他容器之上的；默认轻快下，stack使用deque作为底层容器，但也可以选择使用vector、list等其他容器来作为底层支持

**基本操作：**

```c++
#include<stack>
stack<int> st;
st.push(1);
st.push(2);
int element = st.top();
st.pop();
boo isEmpty = stack.empty();
szie_t stackSize = st.size();
```

**与标准库的区别：**

- 允许实例化中选择不同的底层容器
- 错误处理：添加了异常处理栈为空的情况

**栈特点：**

- 先进后出

**栈溢出：**

- 发生在栈已满的执行push操作
- 栈为空执行pop操作

**如何用栈判断字符串中的括号是否匹配：**

- 遍历整个字符串
- 遇到左括号，将其压入栈
- 如果遇到闭括号，检查栈顶元素是否为对应的开括号
  - 是 栈中弹出栈顶元素
  - 不是 栈为空 字符串括号不平衡
- 遍历结束，若栈为空，则平衡，否则不平衡

## 5 HashTable 实现

HashTable是底层数据结构，无序关联容器包括unordered_set unordered_map 基于哈希表实现。

**什么是哈希表？它是如何工作的？**

- 答案：哈希表是一种使用哈希函数组织数据，以便快速插入和搜索的数据结构。它通过将键映射到表中的位置来存储键值对。哈希函数将每个键转换为哈希表中的索引，该索引决定了键值对在表中的存储位置。如果两个键映射到同一个索引，就会产生冲突，这通常通过链表或开放寻址法来解决。

**哈希冲突是什么？如何处理哈希冲突？**

答案：哈希冲突发生在不同的键通过哈希函数映射到哈希表的同一位置时。处理哈希冲突的方法有：

- **链表法（分离链接法）**：在每个哈希表索引上维护一个链表，所有映射到该索引的元素都会被存储在链表中。
- **开放寻址法**：如果发生冲突，

## 6. RB-Tree的实现 2024.6.4

**结构体：**

```c++
struct Node {
Key key;
Value val;
Color color;
Node *left;
Node *right;
Node *parent;

// 构造函数
Node(const Key &k, Color c, Node *p = nullptr)
    : key(k), color(c), left(nullptr), right(nullptr), parent(p) {}
};
```

每个结构体需要记录自身颜色、键值、左孩子、右孩子和父节点的指针， 该结构体的构造函数会分配父节点指针， 其余指针为空指针;

**insertFixup函数:**

用于插入新节点后修复可能违反红黑树性质的情况。根据红黑树性质进行

1. 颜色调整
2. 旋转

逻辑思路：

1. 父节点是爷爷节点的左孩子
   1. 叔叔节点为红色
      1. 更改叔叔节点和父节点为黑色
      2. 将爷爷节点改为红色
      3. 以爷爷节点为目标继续判断
   2. 叔叔节点为黑色或不存在
      1. 如果新节点是父节点的右孩子，将操作的目标节点变为其父节点，左旋
      2. 操作节点为黑色，爷爷节点红色，
      3. 右旋爷爷节点
2. 父节点是爷爷节点的右孩子
   1. 叔叔红色
      1. 更改叔叔和父节点为黑色
      2. 爷爷设为红色
      3. 以爷爷节点为目标继续调整
   2. 叔叔节点为黑色或不存在
      1. 新节点是父节点的左孩子，将操作的目标节点为其父节点，右旋
      2. 将操作节点设为黑色，爷爷节点为红色
      3. 左旋爷爷节点



**红黑树的特性：**

- 每个节点要么是红色，要么是黑色
- 根节点是黑色
- 叶子节点是黑色
- 如果一个节点是红色，则它的两个子节点都是黑色
- 从任一节点到其每个叶子的所有简单路径都包含相同的黑色节点

**红黑树的时间复杂度是O(logn),其近似平衡的二叉搜索树**

**如何验证一个二叉树是不是红黑树？**

判断是否满足红黑树的五个特性。遍历数的各个节点来检查颜色以及路径上的褐色节点数目是否一致

## 7. Set的实现 2024 06. 08

Set基于红黑树实现，用于存储一组唯一的元素，并按照元素的值进行排序；

Set是有序的关联容器，使用红黑树实现。

特性：

- 唯一性
- 有序性
- 插入元素

使用方法：

`````
#include<set>

std::set<int> myset;

myset.insert(2);

myset.erase(2);

auto it = myset.find(2);
if(it!=myset.end())
{

}

`````

set.find检查是否存在某个值，find返回一个指向该元素的迭代器，否则返回end();

**迭代器类型：**

1. 双向迭代器。不可以随机访问



## 8. unordered_set的实现

1. `std::unordered_set` 和 `std::set` 有什么区别？

主要区别在于内部数据结构和性能特性。`std::set` 基于红黑树实现，保持元素排序，而 `std::unordered_set` 基于哈希表，元素没有特定顺序。因此，`std::unordered_set` 通常提供更快的插入、删除和查找操作，但不支持顺序访问和范围查询。

1. 如何处理 `std::unordered_set` 中的冲突？

`std::unordered_set` 通过链地址法处理哈希冲突。当两个元素的哈希值相同并映射到同一存储位置时，这些元素会被存储在同一存储桶中的链表里。查找元素时，首先计算其哈希值，然后遍历对应存储桶中的链表。

1. 如何自定义 `std::unordered_set` 中元素的哈希函数和相等函数？

在声明 `std::unordered_set` 时，可以提供自定义的哈希函数和相等谓词类型作为模板参数。自定义哈希函数必须是一个接受单个参数（存储在容器中的元素类型）并返回其哈希值的函数。自定义相等函数用于比较两个元素是否相等。

1. `std::unordered_set` 的迭代器是什么类型？它们是如何受到哈希表修改的影响？
2. `std::unordered_set` 提供了正向迭代器，包括常量和非常量版本。迭代器遍历哈希表的存储桶，然后遍历每个存储桶中的链表。增加或删除元素可能会导致存储桶重新哈希，这可能会使现有迭代器失效。然而，删除迭代器当前指向的元素是安全的。
3. 如何优化 `std::unordered_set` 的性能？

优化 `std::unordered_set` 的性能通常涉及选择合适的哈希函数，以减少冲突并保持元素分布均匀。可以通过调用 rehash 方法来增加存储桶的数量，或使用 reserve 方法来提前分配足够的存储空间，以减少重哈希操作的次数。

1. `std::unordered_set` 如何处理元素的删除？

删除操作首先找到要删除的元素的哈希值对应的存储桶，然后在该存储桶的链表中找到并删除该元素。这个过程的平均时间复杂度是 O(1)，但如果存储桶中的元素无序关联容器，内部是哈希表实现

set是红黑树实现，保持元素排序，unorder_set基于哈希表，元素没有特定顺序

## 9. multiset的实现

基于红黑树实现，允许存储多个相同元素，并按照元素的值进行排序；

**特性：**

1. 有序性：
2. 允许重复
3. 基于红黑树实现

1. 解释`multiset`和`Set`的区别是什么？ `multiset`和`Set`都是关联容器，它们可以存储元素，并能够快速检索。它们之间的主要区别在于`multiset`允许存储重复的元素，而`Set`不允许重复元素。这意味着在`multiset`中，可以有多个相同的键值，每个键值都会被计数；而在`Set`中，同一个键值只能出现一次。

2. 在`multiset`中如何统计一个元素的出现次数？ 在`multiset`中，可以通过`count`成员函数来统计某个元素的出现次数。以下是如何使用`count`函数的示例代码：

   ```cpp
   multiset<int> mymultiset;
   // ... (代码中添加一些元素到mymultiset中) ...
   int count = mymultiset.count(5); // 统计元素5出现的次数
   ```

3. 如何在`multiset`中插入和删除元素？ 可以使用`insert`成员函数来向multiset中插入元素。删除元素时，可以使用`erase`函数来删除一定数量的特定元素。以下示例展示了插入和删除操作：

   ```cpp
   multiset<int> mymultiset;
   mymultiset.insert(5); // 插入元素5
   mymultiset.erase(5);  // 删除一个元素5
   ```

4. 如何遍历`multiset`中的所有元素？ 由于`multiset`可能包含重复元素，遍历时可能需要处理每个元素出现的次数。可以使用迭代器来遍历`multiset`中的元素，如下所示：

   ```cpp
   for (auto it = mymultiset.begin(); it != mymultiset.end(); ++it) {
       // 使用*it访问元素的值
   }
   ```

5. `multiset`通常使用什么内部数据结构？ `multiset`通常使用平衡二叉树作为其内部数据结构，最常见的实现是红黑树。红黑树是一种自平衡的二叉搜索树，它可以在对数时间内完成插入、删除和查找操作，保证了`multiset`的高效性能。

6. 如何清空`multiset`中的所有元素？ 若要清空`multiset`中的所有元素，可以使用`clear`成员函数。这会移除`multiset`中的所有元素，并将其大小重置为0。

   ```cpp
   mymultiset.clear(); // 清空multiset
   ```

7. 如果要实现一个`multiset`，关键的操作有哪些？ 实现一个`multiset`时，关键的操作包括元素的插入、搜索、删除和迭代遍历。这些操作都需要高效地处理重复值，并维护内部数据结构的平衡状态。此外，还需要提供一种方法来统计单个键的出现次数，以及清空容器的功能。

8. 使用`multiset`有什么优点？ 使用`multiset`的优点包括能够快速插入、查找和删除元素，特别是当需要处理大量可能重复的数据时。`multiset`自动排序元素，提供了一种自然的方式来维护集合中元素的次序。此外，`multiset`还提供了一些容器操作的便捷性，如统计某个元素的数量、检查集合是否为空等。

## 10. map的实现

map提供键值对存储机制

特性：

- 键值对存储：`std::map`通过键值对的形式存储数据，其中每个键都是唯一的，并且与一个值相关联。
- 自动排序：`std::map`内部使用一种平衡二叉搜索树（通常是红黑树）来存储元素，这使得元素根据键自动排序。
- 元素唯一性：在`std::map`中，键必须是唯一的。如果尝试插入一个已存在的键，插入操作将失败。
- 直接访问：可以使用键直接访问`std::map`中的元素，这提供了高效的查找能力。
- 灵活的元素操作：`std::map`提供了丰富的元素操作，包括插入、删除、查找等

1. **map和unordered_map的区别**

- 内部实现：`std::map`内部基于红黑树实现，因此它的元素是自动排序的。而`std::unordered_map`基于哈希表实现，元素是无序的。
- 性能：对于`std::map`，查找、插入和删除操作的时间复杂度通常是O(log n)。对于`std::unordered_map`，这些操作的平均时间复杂度是O(1)，但最坏情况下是O(n)。
- 内存消耗：由于哈希表的开销，`std::unordered_map`可能会比`std::map`消耗更多内存。
- 元素排序：`std::map`中的元素按照键自动排序，而`std::unordered_map`中的元素没有特定的顺序

**2. emplace和insert的区别**

`emplace`方法会在map中直接构造元素，避免了额外的复制或移动操作。它接受构造元素所需的参数，并且尝试在容器中构造元素。

insert方法用于将已经构造好的元素插入到map中。如果提供了键值对，`insert`可能会导致一次或两次额外的复制或移动构造，首先是创建临时键值对对象，然后是将其插入到容器中。

`emplace`更高效，因为它直接在容器内部构造元素，减少了不必要的复制或移动操作。然而，选择使用`emplace`还是`insert`取决于具体情况，有时为了代码的清晰可读，使用`insert`可能更合适。

## 11. queue的实现

queue是STL中的一个容器适配器，提供了FIFO的功能

默认情况下，queue使用deque作为其底层容器，但是也可以配置为使用list或其他符合要求的容器

**基本使用：**

```c++
que.push(10);
que.push(20);
que.front();
que.back();
que.pop();
```

1. **实现一个队列：**
   - **问题描述：** 使用数组或链表实现一个基本的队列数据结构。
   - **答案概要：** 可以使用动态数组（如C++中的`std::vector`）或链表（如C++中的`std::list`）来存储队列中的元素。需要实现基本操作，如`enqueue`（入队），`dequeue`（出队），`front`（查看队首元素）和`isEmpty`（判断队列是否为空）。
2. **使用栈实现队列：**
   - **问题描述：** 如何仅使用栈数据结构实现队列的功能？
   - **答案概要：** 使用两个栈，一个用于入队操作，另一个用于出队操作。当执行出队操作且出队栈为空时，将入队栈中的所有元素逐个弹出并压入出队栈，这样出队栈的顶部就是最早入队的元素。
3. **队列和栈的区别：**
   - **问题描述：** 描述队列和栈这两种数据结构的区别。
   - **答案概要：** 队列是先进先出（FIFO）的数据结构，而栈是后进先出（LIFO）的数据结构。在队列中，元素从一端添加（队尾），从另一端移除（队头）；而在栈中，元素在同一端添加和移除。
4. **循环队列的实现：**
   - **问题描述：** 如何实现一个循环队列，并解释它的优势？
   - **答案概要：** 循环队列可以使用一个固定大小的数组和两个指针（头指针和尾指针）来实现。当尾指针到达数组的末尾时，它会循环回到数组的开始位置。循环队列的优势在于它可以重复使用空间，减少了因为扩容而带来的性能开销。
5. **阻塞队列和非阻塞队列的区别：**
   - **问题描述：** 解释阻塞队列和非阻塞队列之间的区别。
   - **答案概要：** 阻塞队列在队列为空时会阻塞出队操作，在队列满时会阻塞入队操作。非阻塞队列不会阻塞线程；如果操作不能立即进行，则会失败或返回特定值。
6. **队列的应用场景：**
   - **问题描述：** 举例说明队列在实际应用中的场景。
   - **答案概要：** 队列常用于各种资源的排队管理，如操作系统中的任务调度、网络中的数据包管理、打印任务管理等。它们也广泛用于算法中，如宽度优先搜索（BFS）。

## 12. priority_queue 的实现

`priority_queue` 的底层是堆。

**堆的工作原理：**

堆（Heap）是一种特殊的完全二叉树，它满足下面的性质：

1. **结构性质：** 堆是一个完全二叉树，这意味着除了最后一层外，每一层都是完全填满的，而最后一层的节点则尽可能地集中在左边。
2. **堆性质：** 在一个最大堆（Max Heap）中，每个节点的值都大于或等于其子节点的值，根节点的值是堆中的最大值。相反，在一个最小堆（Min Heap）中，每个节点的值都小于或等于其子节点的值，根节点的值是堆中的最小值。

### 堆的插入和删除：

- **插入操作（Insertion）：** 插入新元素时，新元素首先被放置在树的最后一个位置，以保持完全二叉树的结构。然后，该元素会通过一个称为“上浮”（或“堆化”）的过程，与其父节点比较并交换位置（如果在最大堆中新元素比父节点大，或在最小堆中新元素比父节点小）。这个过程重复进行，直到新元素到达一个位置，它不再比父节点大（或小，取决于是最大堆还是最小堆），或者它已经到达了树的顶部。
- **删除操作（Deletion）：** 在堆中，删除操作通常指的是删除根节点，即最大元素或最小元素。删除后，堆的结构性质必须得到维护。这通常通过将最后一个元素移到根节点的位置来完成，接着执行“下沉”（或“堆化”）过程，该元素会与其子节点比较并根据需要与较大（或较小）的子节点交换位置。这个过程持续进行，直到该元素位于正确的位置，或者它已经到达了树的底部。
- **构建堆（Heapify）：** 从无序数组构建堆的过程称为堆化（Heapify）。这可以通过从最后一个非叶子节点开始，对每个节点执行下沉操作来完成。在数组中，给定索引为`i`的元素，其左子节点的索引为`2*i + 1`，右子节点的索引为`2*i + 2`，父节点的索引为`(i-1)/2`。



