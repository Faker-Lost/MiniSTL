# MiniSTL

## 1.Vector 容器 2024.5.27

**1 vector的扩容过程**

1.分配一个更大的内存块，通常时当前大小的两倍；

2.将当前的所有元素移到新的内存中；

3.销毁旧元素，并释放旧内存块；

4.插入新元素

**2 vector中push_back和emplace的区别：**

`std::vector::push_back` 和 `std::vector::emplace_back` 都是在 `std::vector` 的末尾添加一个新元素，但它们添加元素的方式不同。

- `push_back` 会对给定的对象进行拷贝或移动构造，以将元素添加到 `vector` 的末尾。
- `emplace_back` 则使用给定的参数直接在 `vector` 的末尾构造一个元素，无需拷贝或移动操作，这通常更高效。

**3 reserve()的使用：**

`std::vector::reserve()` 用于预分配内存，以避免在添加新元素时重新分配内存。当知道将要存储大量元素，但又不想在每次插入时都可能发生内存重新分配时，使用 `reserve()` 可以提高性能。这样可以减少因扩容导致的不必要的内存分配和元素拷贝。

**4 如何减少vector的占用空间：**

可以使用 `std::vector::shrink_to_fit` 方法来请求移除未使用的容量，减少 `vector` 的内存使用。这个函数是 C++11 引入的，它会尝试压缩 `std::vector` 的容量，使其等于其大小。但是，这只是一个请求，并不保证容量会减少，因为这依赖于实现。

**5 如何检查vector为空：**

使用 `std::vector::empty()` 方法可以检查 `vector` 是否没有元素。这比使用 `size()` 方法（比较 `size() == 0`）更首选，因为 `empty()` 通常可以保证是常数时间复杂度的操作。

**6 迭代器失效，如何避免:**

当 `vector` 进行操作，如增加或删除元素，尤其是在中间插入或删除元素时，迭代器可能会失效。例如：

- 如果 `vector` 进行了重新分配，所有指向元素的迭代器都会失效。
- 如果在 `vector` 中间插入或删除元素，从该点到末尾的所有迭代器都会失效。

解决方案是最好使用标准库提供的算法，如 `std::remove` 和 `std::remove_if` 结合 `vector::erase` 方法来删除元素。这些算法在设计时已经考虑了迭代器失效的问题。

## List容器

**1.删除list中的特定元素：**

```c++
template <typename T>
void removeAllInstances(std::list<T>& lst, const T& value) {
    for (auto it = lst.begin(); it != lst.end(); /* no increment here */) {
        if (*it == value) {
            it = lst.erase(it);  // erase() returns iterator to the next element
        } else {
            ++it;  // Only increment if not erased
        }
    }
}
```

**2. STL中list特性：**

list是一个序列容器，允许非联系内存分配

list有以下重要特性：

- 双向链表：允许两个方向遍历。
- 非连续内存：由于它是链表，元素不存储在连续的内存位置。这意味着除了通过迭代器外，无法通过常规索引来访问元素。
- 动态大小：与数组不同，list可以根据需要动态增长或缩减
- 插入和删除：时间复杂度O(1)。
- 不支持随机访问：不支持快速随机访问，时间复杂度为O(n)。
- 额外内存开销：每个元素都需要额外的内存来存储前后元素的指针。

**3.list的迭代器失效情况：**

- **插入操作**：在 `list` 中插入操作不会导致任何现有迭代器失效，包括指向插入位置的迭代器。插入操作后，原来的迭代器仍然指向它们原来指向的元素。
- **删除操作**：删除操作会导致指向被删除元素的迭代器失效。然而，其他迭代器，包括指向前一个和后一个元素的迭代器，仍然有效。

**4. list和vector的区别：**

- **内部实现**：
  - `list` 是一个双向链表，不支持随机访问。
  - `vector` 是一个动态数组，支持快速随机访问。
- **性能特点**：
  - list：
    - 插入和删除操作快（O(1)），不论在容器中的哪个位置。
    - 遍历操作慢（O(n)），因为它不支持随机访问。
  - vector：
    - 插入和删除操作在尾部快（O(1)），但在中间或开头慢（O(n)），因为可能需要移动元素。
    - 遍历- **内部实现**：
  - `vector` 是基于连续内存空间的动态数组实现，这意味着它的元素存储在一个连续的内存块中。
  - `list` 是基于双向链表实现的，它的每个元素都是单独的内存块，通过指针连接。